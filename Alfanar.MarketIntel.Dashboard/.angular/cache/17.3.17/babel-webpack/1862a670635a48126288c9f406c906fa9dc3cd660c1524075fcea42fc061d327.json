{"ast":null,"code":"import { BehaviorSubject } from 'rxjs';\nimport * as signalR from '@microsoft/signalr';\nimport * as i0 from \"@angular/core\";\nexport let SignalRService = /*#__PURE__*/(() => {\n  class SignalRService {\n    constructor() {\n      this.connection = null;\n      this.alertsSubject = new BehaviorSubject([]);\n      this.metricsSubject = new BehaviorSubject([]);\n      this.connectionStatusSubject = new BehaviorSubject(false);\n      this.reconnectAttempts = 0;\n      this.maxReconnectAttempts = 5;\n      this.reconnectDelayMs = 2000;\n    }\n    startConnection(hubUrl) {\n      if (this.connection && this.connection.state === signalR.HubConnectionState.Connected) {\n        return;\n      }\n      this.connection = new signalR.HubConnectionBuilder().withUrl(hubUrl).withAutomaticReconnect([0, 2000, 10000]).withServerTimeout(30000).build();\n      this.setupEventListeners();\n      this.connectWithRetry();\n    }\n    connectWithRetry() {\n      if (!this.connection) return;\n      this.connection.start().then(() => {\n        console.log('SignalR connected');\n        this.connectionStatusSubject.next(true);\n        this.reconnectAttempts = 0;\n      }).catch(err => {\n        console.error('SignalR connection error:', err);\n        this.connectionStatusSubject.next(false);\n        this.scheduleReconnect();\n      });\n    }\n    scheduleReconnect() {\n      if (this.reconnectAttempts < this.maxReconnectAttempts) {\n        this.reconnectAttempts++;\n        setTimeout(() => this.connectWithRetry(), this.reconnectDelayMs * this.reconnectAttempts);\n      }\n    }\n    setupEventListeners() {\n      if (!this.connection) return;\n      this.connection.on('ReceiveAlert', alert => {\n        const currentAlerts = this.alertsSubject.value;\n        this.alertsSubject.next([alert, ...currentAlerts]);\n      });\n      this.connection.on('ReceiveMetricUpdate', metric => {\n        const currentMetrics = this.metricsSubject.value;\n        const updatedMetrics = currentMetrics.filter(m => m.name !== metric.name);\n        this.metricsSubject.next([metric, ...updatedMetrics]);\n      });\n      this.connection.onreconnected(() => {\n        console.log('SignalR reconnected');\n        this.connectionStatusSubject.next(true);\n      });\n      this.connection.onreconnecting(() => {\n        console.log('SignalR reconnecting...');\n        this.connectionStatusSubject.next(false);\n      });\n      this.connection.onclose(() => {\n        console.log('SignalR disconnected');\n        this.connectionStatusSubject.next(false);\n      });\n    }\n    getAlerts$() {\n      return this.alertsSubject.asObservable();\n    }\n    getMetrics$() {\n      return this.metricsSubject.asObservable();\n    }\n    getConnectionStatus() {\n      return this.connectionStatusSubject.asObservable();\n    }\n    acknowledgeAlert(alertId) {\n      if (this.connection && this.connection.state === signalR.HubConnectionState.Connected) {\n        this.connection.invoke('AcknowledgeAlert', alertId).catch(err => console.error(err));\n      }\n    }\n    dismissAlert(alertId) {\n      if (this.connection && this.connection.state === signalR.HubConnectionState.Connected) {\n        this.connection.invoke('DismissAlert', alertId).catch(err => console.error(err));\n      }\n    }\n    clearAllAlerts() {\n      if (this.connection && this.connection.state === signalR.HubConnectionState.Connected) {\n        this.connection.invoke('ClearAllAlerts').catch(err => console.error(err));\n      }\n    }\n    subscribeToFeed(feedId) {\n      if (this.connection && this.connection.state === signalR.HubConnectionState.Connected) {\n        this.connection.invoke('SubscribeToFeed', feedId).catch(err => console.error(err));\n      }\n    }\n    unsubscribeFromFeed(feedId) {\n      if (this.connection && this.connection.state === signalR.HubConnectionState.Connected) {\n        this.connection.invoke('UnsubscribeFromFeed', feedId).catch(err => console.error(err));\n      }\n    }\n    stopConnection() {\n      if (this.connection) {\n        this.connection.stop().catch(err => console.error(err));\n      }\n    }\n    static {\n      this.ɵfac = function SignalRService_Factory(t) {\n        return new (t || SignalRService)();\n      };\n    }\n    static {\n      this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n        token: SignalRService,\n        factory: SignalRService.ɵfac,\n        providedIn: 'root'\n      });\n    }\n  }\n  return SignalRService;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}